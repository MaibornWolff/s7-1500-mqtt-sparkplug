FUNCTION "mqttSparkplugEncodeNumericValue" : Int
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      Value : LWord;
   END_VAR

   VAR_IN_OUT 
      ByteArray : Array[0..9] of Byte;
   END_VAR

   VAR_TEMP 
      length : DInt;
   END_VAR


BEGIN
	// Init
	#length := 0;
	#ByteArray[0] := 0;
	#ByteArray[1] := 0;
	#ByteArray[2] := 0;
	#ByteArray[3] := 0;
	#ByteArray[4] := 0;
	#ByteArray[5] := 0;
	#ByteArray[6] := 0;
	#ByteArray[7] := 0;
	#ByteArray[8] := 0;
	#ByteArray[9] := 0;
	
	// encode varint
	// https://developers.google.com/protocol-buffers/docs/encoding#varints
	CASE #Value OF
	    2#1_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000..
	    2#1_1111111_1111111_1111111_1111111_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28) OR 2#1000_0000;
	        #ByteArray[#length + 5] := SHR(IN := #Value, N := 35) OR 2#1000_0000;
	        #ByteArray[#length + 6] := SHR(IN := #Value, N := 42) OR 2#1000_0000;
	        #ByteArray[#length + 7] := SHR(IN := #Value, N := 49) OR 2#1000_0000;
	        #ByteArray[#length + 8] := SHR(IN := #Value, N := 56) OR 2#1000_0000;
	        #ByteArray[#length + 9] := SHR(IN := #Value, N := 63);
	        #length := 10;
	    2#0_0000001_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000..
	    2#0_1111111_1111111_1111111_1111111_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28) OR 2#1000_0000;
	        #ByteArray[#length + 5] := SHR(IN := #Value, N := 35) OR 2#1000_0000;
	        #ByteArray[#length + 6] := SHR(IN := #Value, N := 42) OR 2#1000_0000;
	        #ByteArray[#length + 7] := SHR(IN := #Value, N := 49) OR 2#1000_0000;
	        #ByteArray[#length + 8] := SHR(IN := #Value, N := 56);
	        #length := 9;
	    2#0_0000000_0000001_0000000_0000000_0000000_0000000_0000000_0000000_0000000..
	    2#0_0000000_1111111_1111111_1111111_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28) OR 2#1000_0000;
	        #ByteArray[#length + 5] := SHR(IN := #Value, N := 35) OR 2#1000_0000;
	        #ByteArray[#length + 6] := SHR(IN := #Value, N := 42) OR 2#1000_0000;
	        #ByteArray[#length + 7] := SHR(IN := #Value, N := 49);
	        #length := 8;
	    2#0_0000000_0000000_0000001_0000000_0000000_0000000_0000000_0000000_0000000..
	    2#0_0000000_0000000_1111111_1111111_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28) OR 2#1000_0000;
	        #ByteArray[#length + 5] := SHR(IN := #Value, N := 35) OR 2#1000_0000;
	        #ByteArray[#length + 6] := SHR(IN := #Value, N := 42);
	        #length := 7;
	    2#0_0000000_0000000_0000000_0000001_0000000_0000000_0000000_0000000_0000000..
	    2#0_0000000_0000000_0000000_1111111_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28) OR 2#1000_0000;
	        #ByteArray[#length + 5] := SHR(IN := #Value, N := 35);
	        #length := 6;
	    2#0_0000000_0000000_0000000_0000000_0000001_0000000_0000000_0000000_0000000..
	    2#0_0000000_0000000_0000000_0000000_1111111_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21) OR 2#1000_0000;
	        #ByteArray[#length + 4] := SHR(IN := #Value, N := 28);
	        #length := 5;
	    2#0_0000000_0000000_0000000_0000000_0000000_0000001_0000000_0000000_0000000..
	    2#0_0000000_0000000_0000000_0000000_0000000_1111111_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14) OR 2#1000_0000;
	        #ByteArray[#length + 3] := SHR(IN := #Value, N := 21);
	        #length := 4;
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_0000001_0000000_0000000..
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_1111111_1111111_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0) OR 2#1000_0000;
	        #ByteArray[#length + 1] := SHR(IN := #Value, N := 7) OR 2#1000_0000;
	        #ByteArray[#length + 2] := SHR(IN := #Value, N := 14);
	        #length := 3;
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000001_0000000..
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_0000000_1111111_1111111:
	        #ByteArray[#length] := LWORD_TO_BYTE(SHR(IN := #Value, N := 0)) OR 2#1000_0000;
	        #ByteArray[#length + 1] := LWORD_TO_BYTE(SHR(IN := #Value, N := 7));
	        #length := 2;
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000..
	    2#0_0000000_0000000_0000000_0000000_0000000_0000000_0000000_0000000_1111111:
	        #ByteArray[#length] := SHR(IN := #Value, N := 0);
	        #length := 1;
	END_CASE;
	#mqttSparkplugEncodeNumericValue := #length;
	
END_FUNCTION

FUNCTION "mqttSparkplugEncodeMetric" : Int
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_OUTPUT 
      ValueHeaderDatatypeLength : Int;
      ValueLength : Int;
      MetricFieldValue : Byte;
   END_VAR

   VAR_IN_OUT 
      mqttMetric : "MqttPubMetricsSparkplugUdt";
      ByteArray : Array[0..9] of Byte;
   END_VAR

   VAR_TEMP 
      retVal : Int;
   END_VAR

   VAR CONSTANT 
      HEADER_LENGTH_VALUE_STRING : Int := 2;
      HEADER_LENGTH_VALUE_NUMERIC : Int := 1;
      METRICS_FIELD10_INT_VALUE : Byte := 16#50;   // 32 Bit
      METRICS_FIELD11_LONG_VALUE : Byte := 16#58;   // 64 Bit
      METRICS_FIELD12_FLOAT_VALUE : Byte := 16#65;   // 32 Bit
      METRICS_FIELD14_BOOLEAN_VALUE : Byte := 16#70;
      METRICS_FIELD15_STRING_VALUE : Byte := 16#7A;
      RETVAL_OK : Int := 0;
      RETVAL_INVALID_TYPE : Int := -1;
   END_VAR


BEGIN
	// encode metric
	#retVal := #RETVAL_OK;
	IF #mqttMetric.MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_STRING
	THEN
	    #ValueLength := LEN(#mqttMetric.MetricValue.ValueString);
	    Strg_TO_Chars(Strg := #mqttMetric.MetricValue.ValueString,
	                  pChars := 0,
	                  Cnt => #ValueLength,
	                  Chars := #ByteArray);
	    #ValueHeaderDatatypeLength := #HEADER_LENGTH_VALUE_STRING;
	    #MetricFieldValue := #METRICS_FIELD15_STRING_VALUE;
	ELSIF #mqttMetric.MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_INT32
	THEN
	    #ValueLength := "mqttSparkplugEncodeNumericValue"(Value := #mqttMetric.MetricValue.ValueLWord, ByteArray := #ByteArray);
	    #ValueHeaderDatatypeLength := #HEADER_LENGTH_VALUE_NUMERIC;
	    #MetricFieldValue := #METRICS_FIELD10_INT_VALUE;
	ELSIF #mqttMetric.MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_INT64
	THEN
	    #ValueLength := "mqttSparkplugEncodeNumericValue"(Value := #mqttMetric.MetricValue.ValueLWord, ByteArray := #ByteArray);
	    #ValueHeaderDatatypeLength := #HEADER_LENGTH_VALUE_NUMERIC;
	    #MetricFieldValue := #METRICS_FIELD11_LONG_VALUE;
	ELSIF #mqttMetric.MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_FLOAT
	THEN
	    #ByteArray[0] := #mqttMetric.MetricValue.ValueLWord.%B0;
	    #ByteArray[1] := #mqttMetric.MetricValue.ValueLWord.%B1;
	    #ByteArray[2] := #mqttMetric.MetricValue.ValueLWord.%B2;
	    #ByteArray[3] := #mqttMetric.MetricValue.ValueLWord.%B3;
	    #ValueLength := 4;
	    #ValueHeaderDatatypeLength := #HEADER_LENGTH_VALUE_NUMERIC;
	    #MetricFieldValue := #METRICS_FIELD12_FLOAT_VALUE;
	ELSIF #mqttMetric.MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_BOOLEAN
	THEN
	    #ValueLength := 16#1;
	    #ByteArray[0] := #mqttMetric.MetricValue.ValueLWord.%B0;
	    #ValueHeaderDatatypeLength := #HEADER_LENGTH_VALUE_NUMERIC;
	    #MetricFieldValue := #METRICS_FIELD14_BOOLEAN_VALUE;
	ELSE
	    #retVal := #RETVAL_INVALID_TYPE;
	END_IF;
	#mqttSparkplugEncodeMetric := #retVal;
END_FUNCTION

FUNCTION "LGF_Random_UDInt" : UDInt
TITLE = LGF_Random_UDInt
{ S7_Optimized_Access := 'TRUE' }
AUTHOR : Siemens_Digital_Industries
FAMILY : LGF
NAME : LGF_Random_UDInt
//This function generates a random value with each call.  
//The random number has the data type UDInt.
   VAR_OUTPUT 
      error : Bool;   // FALSE: No error  TRUE: An error occurred during the execution of the FB
      status : Word;   // 16#0000-16#7FFF: Status of the FB  16#8000-16#FFFF: Error identification (see following Table)
      subfunctionStatus : Word;   // Status or return value of called FB's, FC's and system blocks
   END_VAR

   VAR_TEMP 
      tempTime {InstructionName := 'DTL'; LibVersion := '1.0'} : DTL;   // Temp memory for System time
      tempNanoSecondInDWord : DWord;   // Temp UDInt converted to DWord for access to individual bytes
      tempTimeStatus : Word;   // Temp status of the instruction `RD_SYS_T`
      tempRandomValue : DWord;   // Temp Random startvalue
   END_VAR

   VAR CONSTANT 
      ZERO : UDInt := 0;   // Zero / 0.0 - value in case of  error
      SUB_STATUS_NO_ERROR : Word := 16#0000;   // Status: sub function call ends without error
      STATUS_FINISHED_NO_ERROR : Word := 16#0000;   // Execution finished without errors
      ERR_RD_SYS_T : Word := 16#8600;   // Error in `RD_SYS_T` command - check `subFunctionStatus` code
   END_VAR


BEGIN
	REGION Block info header
	  //=============================================================================
	  // SIEMENS AG / (c)Copyright 2019
	  //-----------------------------------------------------------------------------
	  // Title:            LGF_Random_UDInt
	  // Comment/Function: Generates a random number in the UDInt Range
	  // Library/Family:   LGF(Library General Functions)
	  // Author:           Siemens Digital Industry Support
	  // Tested with:      S7-PLCSIM Advanced V2.0 SP1
	  // Engineering:      TIA Portal V15 Update 2
	  // Restrictions:     ENO disabled - error handling done by error and status
	  // Requirements:     PLC (S7-1200 / S7-1500)
	  //-------------------------------------------------------------------------------
	  // Change log table:
	  // Version  | Date       | Expert in charge       | Changes applied
	  //----------|------------|------------------------|------------------------------
	  // 01.00.00 11.12.2019  Simatic Systems Support
	  //                      First release
	  //                      copied from "LGF_Random_Real"
	  // 03.00.00 23.04.2020  Simatic Systems Support
	  //                      Set version to V3.0.0, harmonize the version of the whole library
	  // 03.00.01 04.02.2021  Simatic Systems Support
	  //                      Insert documentation
	  //=============================================================================
	END_REGION Block info header
	
	REGION DESCRIPTION
	  (/*
	Note
	:    The status of called commands is output in `subFunctionStatus`. In this case, the output value in `status` indicates which command caused the error. In this case, refer to the TIA Portal Online Help section for information on the respective commands.
	
	The function generates random values in the range:  
	$ 0 ≤ ReturnVal ≤ 4294967295 $.
	
	The random value is formed from the nanoseconds of the current system time of the CPU. The byte order of this value is inverted and then converted to UDInt.
	*/)
	END_REGION DESCRIPTION
	
	REGION Validation
	  // Read system time
	  #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));
	  
	  // Check return variable for error
	  IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN
	    #error := true;
	    #status := #ERR_RD_SYS_T;
	    #subfunctionStatus := #tempTimeStatus;
	    #LGF_Random_UDInt := #ZERO;
	    RETURN;
	  END_IF;
	END_REGION
	
	REGION Calculating random number
	  // Converting to double word so individual bytes can be addressed
	  #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);
	  
	  // Calculate a random-start-value depending on the time
	  #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;
	  #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;
	  #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;
	  #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;
	  
	  #LGF_Random_UDInt := DWORD_TO_UDINT(#tempRandomValue);
	  
	  #error := false;
	  #status := #STATUS_FINISHED_NO_ERROR;
	  #subfunctionStatus := #SUB_STATUS_NO_ERROR;
	  // ENO mechanism is not used
	  ENO := TRUE;
	END_REGION
	
END_FUNCTION

FUNCTION "mqttSparkplugEncode" : Void
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      messageType : String;
   END_VAR

   VAR_IN_OUT 
      mqttMetric : Array[*] of "MqttPubMetricsSparkplugUdt";
      buffer : Array[0..65535] of Byte;
      length : DInt;
   END_VAR

   VAR_TEMP 
      i : Int;
      "time" : LWord;
      timestampLength : Int;
      timestampByteArray : Array[0..9] of Byte;
      metricsLowerBound : Int;
      metricsUpperBound : Int;
      metricsCnt : Int;
      metricsFieldValue : Byte;
      metricValueByteArray : Array[0..9] of Byte;
      valueHeaderDatatypeLength : Int;
      valueLength : Int;
      payloadLength : Int;
      retValMqttSparkplugEncodeMetric : Int;
      metricBirth : "MqttPubMetricsSparkplugUdt";
   END_VAR

   VAR CONSTANT 
      TIMESTAMP : Byte := 16#08;
      METRICS : Byte := 16#12;
      METRICS_FIELD1_NAME : Byte := 16#0A;
      METRICS_FIELD3_TIMESTAMP : Byte := 16#18;
      METRICS_FIELD4_DATATYP : Byte := 16#20;
      METRICS_FIELD14_BOOLEAN_VALUE : Byte := 16#70;
      HEADER_LENGTH_NAME : Int := 2;
      HEADER_LENGTH_TIMESTAMP : Int := 1;
      HEADER_LENGTH_DATATYPE : Int := 2;
      RETVAL_OK : Int := 0;
      MESSAGE_TYP_NBIRTH : String := 'NBIRTH';
      MESSAGE_TYP_NDATA : String := 'NDATA';
   END_VAR


BEGIN
	// Payload
	// Timestamp
	#time := ULINT_TO_LWORD(DWORD_TO_ULINT("Unixtime"()) * 1000);
	#buffer[#length] := #TIMESTAMP;
	#length := #length + 1;
	#timestampLength := "mqttSparkplugEncodeNumericValue"(Value := #time, ByteArray := #timestampByteArray);
	FOR #i := 0 TO #timestampLength - 1 DO
	    #buffer[#length + #i] := #timestampByteArray[#i];
	END_FOR;
	#length := #length + #timestampLength;
	// add all metrics to message
	#metricsLowerBound := LOWER_BOUND(ARR := #mqttMetric, DIM := 1);
	#metricsUpperBound := UPPER_BOUND(ARR := #mqttMetric, DIM := 1);
	FOR #metricsCnt := #metricsLowerBound TO #metricsUpperBound DO
	    // encode metric
	    #retValMqttSparkplugEncodeMetric :=
	         "mqttSparkplugEncodeMetric"(ValueHeaderDatatypeLength => #valueHeaderDatatypeLength,
	                                    ValueLength => #valueLength,
	                                    MetricFieldValue => #metricsFieldValue,
	                                    mqttMetric := #mqttMetric[#metricsCnt],
	                                    ByteArray := #metricValueByteArray);
	        
	    IF #retValMqttSparkplugEncodeMetric = #RETVAL_OK THEN
	        #buffer[#length] := #METRICS;
	        #length := #length + 1;
	        
	        // metric length
	        IF #messageType = #MESSAGE_TYP_NBIRTH
	        THEN
	            #valueLength := 1;
	            #valueHeaderDatatypeLength := 1;
	        END_IF;
	        #buffer[#length]
	        := LEN(#mqttMetric[#metricsCnt].Name) + #valueLength + #timestampLength + #valueHeaderDatatypeLength
	        + #HEADER_LENGTH_NAME + #HEADER_LENGTH_TIMESTAMP + #HEADER_LENGTH_DATATYPE;
	        #length := #length + 1;
	        
	        #buffer[#length] := #METRICS_FIELD1_NAME;
	        #length := #length + 1;
	        
	        // name length
	        #buffer[#length] := LEN(#mqttMetric[#metricsCnt].Name);
	        #length := #length + 1;
	        
	        // name
	        Strg_TO_Chars(Strg := #mqttMetric[#metricsCnt].Name,
	                      pChars := #length,
	                      Cnt => #payloadLength,
	                      Chars := #buffer);
	        #length := #payloadLength + #length;
	        
	        // timestamp
	        #buffer[#length] := #METRICS_FIELD3_TIMESTAMP;
	        #length := #length + 1;
	        FOR #i := 0 TO #timestampLength - 1 DO
	            #buffer[#length + #i] := #timestampByteArray[#i];
	        END_FOR;
	        #length := #length + #timestampLength;
	        
	        // datatyp
	        #buffer[#length] := #METRICS_FIELD4_DATATYP;
	        #length := #length + 1;
	        IF #messageType = #MESSAGE_TYP_NBIRTH
	        THEN
	            #buffer[#length] := "mqttGlobals".SPARKPLUG_DATATYP_BOOLEAN;
	        ELSE
	            #buffer[#length] := #mqttMetric[#metricsCnt].MetricValue.Datatype;
	        END_IF;
	        #length := #length + 1;
	        
	        // value
	
	        IF #messageType = #MESSAGE_TYP_NBIRTH
	        THEN
	            #buffer[#length] := #METRICS_FIELD14_BOOLEAN_VALUE;
	            #length := #length + 1;
	            #buffer[#length] := 1;
	            #length := #length + 1;
	        ELSE
	            #buffer[#length] := #metricsFieldValue;
	            #length := #length + 1;
	            IF #mqttMetric[#metricsCnt].MetricValue.Datatype = "mqttGlobals".SPARKPLUG_DATATYP_STRING
	            THEN
	                //datatype string: add value length
	                #buffer[#length] := #valueLength;
	                #length := #length + 1;
	            END_IF;
	            FOR #i := 0 TO #valueLength - 1 DO
	                #buffer[#length + #i] := #metricValueByteArray[#i];
	            END_FOR;
	            #length := #valueLength + #length;
	        END_IF;
	    END_IF;
	
	END_FOR;
	
	
END_FUNCTION

FUNCTION "mqttSparkplugPrepMetrik" : Int
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      MetricValue : Variant;   // Valid datatypes: Int, DInt, LInt, Real, Bool, String
   END_VAR

   VAR_IN_OUT 
      MqttMetrik : "MqttPubMetricsSparkplugUdt";
   END_VAR

   VAR_TEMP 
      valueString : String;
      retValMove : Int;
      lengthPayload : Int;
      tempInt : Int;
      tTempDint : DInt;
      tempLint : LInt;
      tempReal : Real;
      tempBool : Bool;
      retVal : Int;
      tempString : String;
      lenString : Int;
      cntChar : Int;
      i : Int;
      chars : Array[1..254] of Char;
      offset : Int;
   END_VAR

   VAR CONSTANT 
      RETVAL_OK : Int := 0;
      RETVAL_INVALID_TYPE : Int := -1;
      CHAR_VALUE_22 : Byte := 16#22;   // "
      CHAR_VALUE_2E : Byte := 16#2E;   // .
   END_VAR


BEGIN
	#retVal := #RETVAL_OK;
	REGION get metric name
	    //read symbolic name of the variable and convert it to sparkplug metric format
	    #tempString := WSTRING_TO_STRING(GetSymbolName(variable := #MetricValue, size := 0));
	    #lenString := LEN(#tempString);
	    Strg_TO_Chars(Strg := #tempString,
	                  pChars := 0,
	                  Cnt => #cntChar,
	                  Chars := #chars);
	    #i := 1;
	    WHILE #i < #lenString DO
	        IF #chars[#i] = #CHAR_VALUE_22 THEN
	            #tempString := REPLACE(IN1 := #tempString, IN2 := '', L := 1, P := #i - #offset);
	            #offset := #offset + 1;
	            #lenString := LEN(#tempString);
	        END_IF;
	        IF #chars[#i] = #CHAR_VALUE_2E THEN
	            #tempString := REPLACE(IN1 := #tempString, IN2 := '/', L := 1, P := #i - #offset);
	        END_IF;
	        #i := #i + 1;
	    END_WHILE;
	    #MqttMetrik.Name := #tempString;
	END_REGION
	
	REGION get datatype and value
	    IF TypeOf(#MetricValue) = Int THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_INT32;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tempInt);
	        #MqttMetrik.MetricValue.ValueLWord := #tempInt;
	    ELSIF TypeOf(#MetricValue) = DInt THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_INT32;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tTempDint);
	        #MqttMetrik.MetricValue.ValueLWord := #tTempDint;
	    ELSIF TypeOf(#MetricValue) = LInt THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_INT64;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tempLint);
	        #MqttMetrik.MetricValue.ValueLWord := #tempLint;
	    ELSIF TypeOf(#MetricValue) = Real THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_FLOAT;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tempReal);
	        #MqttMetrik.MetricValue.ValueLWord := REAL_TO_DWORD(#tempReal);
	    ELSIF TypeOf(#MetricValue) = Bool THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_BOOLEAN;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tempBool);
	        #MqttMetrik.MetricValue.ValueLWord := BOOL_TO_BYTE(#tempBool);
	    ELSIF TypeOf(#MetricValue) = String THEN
	        #MqttMetrik.MetricValue.Datatype := "mqttGlobals".SPARKPLUG_DATATYP_STRING;
	        #retValMove := MOVE_BLK_VARIANT(SRC := #MetricValue, COUNT := 1, SRC_INDEX := 0, DEST_INDEX := 0, DEST => #valueString);
	        #MqttMetrik.MetricValue.ValueString := #valueString;
	    ELSE
	        #retVal := #RETVAL_INVALID_TYPE;
	    END_IF;
	END_REGION
	
	#mqttSparkplugPrepMetrik := #retVal;
	
END_FUNCTION

FUNCTION_BLOCK "mqttSparkplug"
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Maul
VERSION : 1.0
   VAR_INPUT 
      connectionParameter : "ConParUdt";
   END_VAR

   VAR_OUTPUT 
      pubTopic : String[254];
      pubTopicChar { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} AT pubTopic : Array[0..255] of Char;
      payload : Array[0..4096] of Byte;
      payloadSize : Int;
      RecBufFull : Bool;
   END_VAR

   VAR_IN_OUT 
      callback : Bool;
      callbackPacketType : Int;
      mqttData : "MqttDataUdt";
   END_VAR

   VAR 
      tcpState : Int := 0;
      intState : Int;
      lastState : Int;
      tcpRecByte : Byte;
      myPacketReader : "mqttPacketReader";
      msgId : Int;
      typeOfPacket : Int;
      Runtimer : "mqttRuntime";
      TCP_Timer : "mqttRuntime";
      resetTime : Time;
      tl : Int;
      paylPos : Int;
      paylSize : Int;
      recBufLeft : Int;
      act_send : Bool;
      snd_busy : Bool;
      last_snd_err : Word;
      last_rec_err : Word;
      cntrl_done : Bool;
      cntrl_error : Bool;
      cntrl_status : Word;
      cntrl_lastErrStatus : Word;
      cntrl_res1 : DWord;
      cntrl_res2 : DWord;
      netcmd_success : Bool := FALSE;
      netcmd_busy : Bool := FALSE;
      netcmd_error : Bool := FALSE;
      netcmd_status : Word;
      netcmd_datareceived : Bool := FALSE;
      netcmd_datalength : Int;
      NET_CON {InstructionName := 'TCON'; LibVersion := '4.0'} : TCON;
      NET_DISCON {InstructionName := 'TDISCON'; LibVersion := '2.1'} : TDISCON;
      NET_SEND {InstructionName := 'TSEND'; LibVersion := '4.0'} : TSEND;
      NET_RCV {InstructionName := 'TRCV'; LibVersion := '4.0'} : TRCV;
      NET_CONFIG {InstructionName := 'TCON_IP_v4'; LibVersion := '1.0'} : TCON_IP_v4 := (16#64, (), 16#11, true, ([()]), (), 2000);
      BUSY_TIMER {InstructionName := 'TON_TIME'; LibVersion := '1.0'} : TON_TIME;
   END_VAR

   VAR_TEMP 
      i : Int;
      intTemp : Int;
      TOP_SI {InstructionName := 'SI_classic'; LibVersion := '1.0'} : SI_classic;
      START_UP_SI {InstructionName := 'SI_classic'; LibVersion := '1.0'} : SI_classic;
      tmpPacketID : Int;
      structTmpPacketId AT tmpPacketID : Struct
         byteLSB : Byte;
         byteMSB : Byte;
      END_STRUCT;
   END_VAR

   VAR CONSTANT 
      TCP_STATE_UNINITIALIZED : Int := 0;
      TCP_STATE_INITIALIZING : Int := 1;
      TCP_STATE_INITIALIZED : Int := 2;
      TCP_STATE_CONNECTING : Int := 3;
      TCP_STATE_CONNECTED : Int := 4;
      TCP_STATE_DISCONNECTING : Int := 5;
      TCP_STATE_DISCONNECTED : Int := 6;
      MQTT_STATE_DISCONNECT : Int := -6;
      MQTT_STATE_DISCONNECTING : Int := -5;
      MQTT_STATE_DISCONNECTED : Int := -1;
      MQTT_STATE_CONNECTING : Int := 0;
      MQTT_STATE_CONNECTED : Int := 1;
      WAIT_FOR_RECEIVED_PACKET : Int := 0;
      READ_COMPLETE_PACKET : Int := 1;
      MQTT_CONNECT : Int := 16;
      MQTT_CONNACK : Int := 32;
      MQTT_PUBLISH : Int := 48;
      MQTT_PUBACK : Int := 64;
      MQTT_PUBREC : Int := 80;
      MQTT_PUBREL : Int := 96;
      MQTT_PUBCOMP : Int := 112;
      MQTT_SUBSCRIBE : Int := 130;
      MQTT_SUBACK : Int := 144;
      MQTT_UNSUBSCRIBE : Int := 160;
      MQTT_UNSUBACK : Int := 176;
      MQTT_PINGREQ : Int := 192;
      MQTT_PINGRESP : Int := 208;
      MQTT_DISCONNECT : Int := 224;
      PN : Int := 0;
      CP : Int := 1;
      CN_NOP : Int := 0;
      CN_STATUS : Int := 1;
      CN_RESET : Int := 2;
      CN_STATUS_ALL : Int := 3;
      CN_RESET_ALL : Int := 4;
      CN_CLEAR_RESET : Int := 5;
      CN_DISCON : Int := 6;
      CN_STARTCON : Int := 7;
   END_VAR


BEGIN
	
	(* Check IF CPU had a reset, trigger network reinitialization on reset *)
	//#intTemp := RD_SINFO(TOP_SI => #TOP_SI, START_UP_SI => #START_UP_SI);
	//IF #TOP_SI.EV_NUM <> 3 THEN
	//  #tcpState := #TCP_STATE_UNINITIALIZED;
	//  "mqttData".ethTCPConnected := false;
	//  "mqttData"._state := #MQTT_STATE_DISCONNECTED;
	//END_IF;
	
	
	(* 
	    ******************************
	    TCP/IP State Machine
	    ******************************
	*)
	CASE (#tcpState) OF
	    
	  #TCP_STATE_UNINITIALIZED:
	      #mqttData.ethTCPConnected := false;
	    #tcpState := #TCP_STATE_INITIALIZING;
	    ;
	    
	  #TCP_STATE_INITIALIZING:
	    
	    // *** PN CODE ****
	    
	    // Load IP parameters to NET_CONFIG DB variables for usage in TCON
	    
	    #NET_CONFIG.InterfaceId := 64;
	    #NET_CONFIG.ConnectionType := 16#0B;
	    #NET_CONFIG.LocalPort := 30000;
	    #NET_CONFIG.ID := INT_TO_WORD(#connectionParameter.connectionID);
	    #NET_CONFIG.RemoteAddress.ADDR[1] := INT_TO_BYTE(#connectionParameter.ipBlock1);
	    #NET_CONFIG.RemoteAddress.ADDR[2] := INT_TO_BYTE(#connectionParameter.ipBlock2);
	    #NET_CONFIG.RemoteAddress.ADDR[3] := INT_TO_BYTE(#connectionParameter.ipBlock3);
	    #NET_CONFIG.RemoteAddress.ADDR[4] := INT_TO_BYTE(#connectionParameter.ipBlock4);
	    #NET_CONFIG.RemotePort := #connectionParameter.ipPort;
	    
	    
	    #NET_CON(REQ := false // IN: BOOL
	             ,
	             ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	             ,
	             CONNECT := #NET_CONFIG // INOUT: ANY
	    );
	    
	    #NET_SEND(REQ := false // IN: BOOL
	              ,
	              ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	              ,
	              LEN := 0// IN: INT
	              ,
	              DATA := "mqttDataSparkplug".#tcpSendBuf // INOUT: ANY
	    );
	    
	    #NET_RCV(EN_R := false // IN: BOOL
	             ,
	             ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	             ,
	             LEN := 0 // IN: INT
	             ,
	             DATA := #tcpRecByte // INOUT: ANY
	    );
	    
	    #NET_DISCON(REQ := false // IN: BOOL
	                ,
	                ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	    );
	    
	    // *** PN CODE END ****
	    
	    #tcpState := #TCP_STATE_INITIALIZED;
	    ;
	    
	  #TCP_STATE_INITIALIZED:
	    #tcpState := #TCP_STATE_CONNECTING;
	    ;
	    
	  #TCP_STATE_CONNECTING:
	    
	    // *** PN CODE ****
	    
	    #NET_CON(REQ := true // IN: BOOL
	             ,
	             ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	             ,
	             CONNECT := #NET_CONFIG // INOUT: ANY
	    );
	    #netcmd_success := #NET_CON.DONE; // OUT: BOOL
	    #netcmd_error := #NET_CON.ERROR; // OUT: BOOL
	    #netcmd_status := #NET_CON.STATUS; // OUT: WORD
	    
	    IF #netcmd_success AND (#netcmd_status = W#16#0) THEN
	        #tcpState := #TCP_STATE_CONNECTED;
	        END_IF;
	        #mqttData.ethTCPConnected := true;
	      IF #netcmd_error THEN
	        #cntrl_lastErrStatus := #netcmd_status;
	        #tcpState := #TCP_STATE_DISCONNECTED;
	      END_IF;
	
	    
	    // TCP timeout while connecting reset connection state and try again
	    
	    IF NOT #netcmd_success THEN
	      #TCP_Timer(IN := true,
	                 RES := false);
	      
	      IF TIME_TO_DINT(#TCP_Timer.RTIME) > TIME_TO_DINT("mqttGlobals".TCP_TIMEOUT) THEN
	          #tcpState := #TCP_STATE_DISCONNECTING;
	      END_IF;
	    END_IF;
	    
	    // *** PN CODE END ****
	    ;
	    
	  #TCP_STATE_CONNECTED:
	    
	    // *** PN CODE - Check TCP connection state ****
	    
	    #NET_RCV(EN_R := false // IN: BOOL
	             ,
	             ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	             ,
	             LEN := 0 // IN: INT
	             ,
	             DATA := #tcpRecByte // INOUT: ANY
	    );
	    IF #NET_RCV.STATUS <> W#16#7000 THEN
	        #tcpState := #TCP_STATE_DISCONNECTING;
	    END_IF;
	    ;
	    
	  #TCP_STATE_DISCONNECTING:
	      #mqttData.ethTCPConnected := false;
	    
	    // *** PN CODE ****
	    #NET_DISCON(REQ := true // IN: BOOL
	                ,
	                ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	    );
	    #netcmd_success := #NET_DISCON.DONE; // OUT: BOOL
	    #netcmd_busy := #NET_DISCON.BUSY; // OUT: BOOL
	    #netcmd_error := #NET_DISCON.ERROR; // OUT: BOOL
	    #netcmd_status := #NET_DISCON.STATUS; // OUT: WORD
	    
	    #tcpState := #TCP_STATE_DISCONNECTED;
	    
	    // *** PN CODE END ****
	    ;
	    
	  #TCP_STATE_DISCONNECTED:
	      #mqttData.ethTCPConnected := false;
	    #tcpState := #TCP_STATE_UNINITIALIZED;
	    #TCP_Timer(IN := false,
	               RES := true);
	    ;
	    
	  ELSE:
	    ;
	END_CASE;
	
	(*
	    *******************************************
	    MQTT Timout Handling without TCP Connection
	    *******************************************
	*)
	#Runtimer(IN := ((#mqttData._state = #MQTT_STATE_CONNECTING) OR (#mqttData._state = #MQTT_STATE_CONNECTED)),
	          RES := false);
	#mqttData.runTime := #Runtimer.RTIME;
	
	//Recalculate timeouts when timer is set to T#0
	
	IF TIME_TO_DINT(#mqttData.runTime) = 0 AND (TIME_TO_DINT(#mqttData.lastInActivity) <> 0 OR TIME_TO_DINT(#mqttData.lastOutActivity) <> 0) THEN
	  #Runtimer.run := TIME_TO_DINT("mqttGlobals".MQTT_KEEPALIVE) / 1000;
	  
	  IF TIME_TO_DINT(#mqttData.lastOutActivity) <> 0 THEN
	      #mqttData.lastOutActivity := "mqttGlobals".MQTT_KEEPALIVE - DINT_TO_TIME(2073600000 - TIME_TO_DINT(#mqttData.lastOutActivity));
	  END_IF;
	  
	  IF TIME_TO_DINT(#mqttData.lastInActivity) <> 0 THEN
	      #mqttData.lastInActivity := "mqttGlobals".MQTT_KEEPALIVE - DINT_TO_TIME(2073600000 - TIME_TO_DINT(#mqttData.lastInActivity));
	  END_IF;
	END_IF;
	
	IF (#mqttData._state = #MQTT_STATE_CONNECTING OR #mqttData._state = #MQTT_STATE_CONNECTED) AND #tcpState <> #TCP_STATE_CONNECTED THEN
	    IF ((#mqttData.runTime - #mqttData.lastInActivity) > "mqttGlobals".MQTT_KEEPALIVE) OR ((#mqttData.runTime - #mqttData.lastOutActivity) > "mqttGlobals".MQTT_KEEPALIVE) THEN
	    // Connection Timeout!
	        #mqttData._state := #MQTT_STATE_DISCONNECTED;
	        #mqttData.reqSend := false;
	    #act_send := false;
	    #snd_busy := false;
	  END_IF;
	END_IF;
	
	(* 
	    ******************************
	    TCP/IP Sending and Receiving
	    ******************************
	*)
	IF NOT (#tcpState = #TCP_STATE_CONNECTED) THEN // stop if there's no tcp connection 
	    #snd_busy := false;
	    #act_send := false;
	    RETURN;
	END_IF;
	
	(* TCP SENDING *)
	IF (#mqttData.reqSend AND NOT #snd_busy) THEN
	    #mqttData.reqSend := false;
	    #act_send := true;
	END_IF;
	
	IF #mqttData.reqSend AND #snd_busy THEN
	(* Just a try to stop the process from deadlocking when TCP connection went down *)
	    #BUSY_TIMER(IN := true,
	                PT := T#500MS);
	    
	    IF #BUSY_TIMER.Q THEN
	        #snd_busy := false; // simple reset busy because something went clearly wrong here ...
	        #BUSY_TIMER(IN := false,
	                    PT := T#500MS);
	    END_IF;
	    
	END_IF;
	
	
	// *** PN CODE ****
	#NET_SEND(REQ := #act_send // IN: BOOL
	          ,
	          ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	          ,
	          LEN := #mqttData.sendSize // IN: INT
	          ,
	          DATA := "mqttDataSparkplug".#tcpSendBuf // INOUT: ANY
	);
	#netcmd_success := #NET_SEND.DONE; // OUT: BOOL
	#netcmd_error := #NET_SEND.ERROR; // OUT: BOOL
	#netcmd_status := #NET_SEND.STATUS; // OUT: WORD
	
	// after sending reset send buffer management
	#mqttData.sendSize := 0;
	#mqttData.tcp_sendBufferFull := false;
	
	IF #netcmd_error AND NOT #netcmd_success THEN
	  #last_snd_err := #netcmd_status;
	  #snd_busy := false;
	  
	  IF ((#netcmd_status = W#16#80A1) OR (#netcmd_status = W#16#80C4)) THEN
	      #mqttData.ethTCPConnected := false;
	      #mqttData._state := #MQTT_STATE_DISCONNECTED;
	    #tcpState := #TCP_STATE_DISCONNECTING;
	  END_IF;
	END_IF;
	// *** PN CODE END ****
	
	
	IF (#act_send) THEN
	  #act_send := false;
	  #snd_busy := true;
	END_IF;
	
	IF (#netcmd_success AND #snd_busy) THEN
	  #snd_busy := false;
	END_IF;
	
	
	(* TCP RECEIVING *)
	
	// *** PN CODE ****
	#NET_RCV(EN_R := true // IN: BOOL
	         ,
	         ID := INT_TO_WORD(#connectionParameter.connectionID) // IN: WORD
	         ,
	         LEN := #netcmd_datalength // IN: INT
	         ,
	         DATA := #tcpRecByte // INOUT: ANY
	);
	#netcmd_datareceived := #NET_RCV.NDR; // OUT: BOOL
	#netcmd_error := #NET_RCV.ERROR; // OUT: BOOL
	#netcmd_status := #NET_RCV.STATUS; // OUT: WORD
	#netcmd_datalength := #NET_RCV.RCVD_LEN; // OUT: INT
	
	IF #netcmd_error AND ((#netcmd_status = W#16#80A1) OR (#netcmd_status = W#16#80C4)) THEN
	  #last_rec_err := #netcmd_status;
	  #mqttData._state := #MQTT_STATE_DISCONNECTED;
	  #tcpState := #TCP_STATE_DISCONNECTING;
	END_IF;
	// *** PN CODE END ****
	
	
	IF #netcmd_datareceived THEN
	    IF #mqttData.RecBufFull THEN
	    #RecBufFull := true;
	  ELSE
	      #mqttData.tcpRecBuf[#mqttData.pRec] := #tcpRecByte;
	      #mqttData.pRec := #mqttData.pRec + 1;
	      IF (#mqttData.pRec >= "mqttGlobals".TCP_RECVBUFFERSIZE) THEN
	          #mqttData.pRec := 0;
	    END_IF;
	    IF (#mqttData.pRec = #mqttData.pRead) THEN
	        #mqttData.RecBufFull := true;
	    END_IF;
	  END_IF;
	END_IF;
	
	#myPacketReader(mqttData:=#mqttData);
	
	//debug
	IF (#mqttData.pRec >= #mqttData.pRead) THEN
	    #recBufLeft := "mqttGlobals".TCP_RECVBUFFERSIZE - (#mqttData.pRec - #mqttData.pRead);
	ELSE
	    #recBufLeft := "mqttGlobals".TCP_RECVBUFFERSIZE - (#mqttData.pRead - #mqttData.pRec);
	END_IF;
	
	
	(*
	   ******************************
	   MQTT State Machine
	   ******************************
	*)
	CASE (#mqttData._state) OF
	    
	  #MQTT_STATE_DISCONNECTED:
	      #lastState := #mqttData._state;
	    // TODO: what is this for?
	      IF ((#mqttData.runTime - t#10s) > #resetTime) AND NOT #mqttData.ethTCPConnected THEN
	          #resetTime := #mqttData.runTime;
	    END_IF;
	    ;
	    
	  #MQTT_STATE_CONNECTING:  // this state is triggered by mqttConnect FC
	      IF (#mqttData._state <> #lastState) THEN
	      #intState := #WAIT_FOR_RECEIVED_PACKET;
	      #lastState := #mqttData._state;
	    END_IF;
	    
	    CASE (#intState) OF
	        
	      #WAIT_FOR_RECEIVED_PACKET:
	          IF ((#mqttData.runTime - #mqttData.lastInActivity) >= "mqttGlobals".MQTT_SOCKET_TIMEOUT) THEN
	          // Timeout!
	              #mqttData._state := #MQTT_STATE_DISCONNECTED;
	          ELSIF "mqttAvailable"(mqttData:=#mqttData) THEN
	          #myPacketReader.iBegin := true;
	          #intState := #READ_COMPLETE_PACKET;
	        END_IF;
	        ;
	        
	      #READ_COMPLETE_PACKET:
	        IF (#myPacketReader.xDone) THEN
	          
	            #typeOfPacket := BYTE_TO_INT(#mqttData.buffer[0] AND B#16#F0);
	          
	          IF (#typeOfPacket = "mqttGlobals".MQTTCONNACK) THEN
	              #mqttData.lastInActivity := #mqttData.runTime;
	              #mqttData.pingOutstanding := false;
	            
	              IF BYTE_TO_INT(#mqttData.buffer[3]) = "mqttGlobals".MQTT_CONN_ACCEPTED THEN
	                  #mqttData._state := #MQTT_STATE_CONNECTED;
	            ELSE
	              // MQTT Connection Error!
	                #mqttData._state := #MQTT_STATE_DISCONNECTED;
	              #callbackPacketType := #MQTT_CONNACK;
	              #mqttData.mqttErrorCode := BYTE_TO_INT(#mqttData.buffer[3]);
	              #callback := true;
	            END_IF;
	            // ELSE maybe need equivalent/workaround to client->stop()
	          END_IF;
	        END_IF;
	        ;
	        
	    END_CASE;
	    ;
	    
	  #MQTT_STATE_CONNECTED:
	      IF (#mqttData._state <> #lastState) THEN
	      #intState := #WAIT_FOR_RECEIVED_PACKET;
	      #lastState := #mqttData._state;
	    END_IF;
	    // Check if Keepalive timeout occured.
	    IF ((#mqttData.runTime - #mqttData.lastInActivity) > "mqttGlobals".MQTT_KEEPALIVE) OR ((#mqttData.runTime - #mqttData.lastOutActivity) > "mqttGlobals".MQTT_KEEPALIVE) THEN
	        IF (#mqttData.pingOutstanding) THEN
	        // Ping Timeout!
	            #mqttData._state := #MQTT_STATE_DISCONNECTED;
	      ELSE
	          #mqttData.buffer[0] := INT_TO_BYTE("mqttGlobals".MQTTPINGREQ);
	          #mqttData.buffer[1] := 0;
	        "mqttSendTCP"(offset := 0,
	                      size := 2,
	                      mqttData:=#mqttData);
	        #mqttData.lastOutActivity := #mqttData.runTime;
	        #mqttData.lastInActivity := #mqttData.lastOutActivity;
	        #mqttData.pingOutstanding := true;
	      END_IF;
	    END_IF;
	    
	    CASE (#intState) OF
	        
	      #WAIT_FOR_RECEIVED_PACKET:
	          IF "mqttAvailable"(mqttData:=#mqttData) THEN
	          #myPacketReader.iBegin := true;
	          #msgId := 0;
	          #intState := #READ_COMPLETE_PACKET;
	        END_IF;
	        ;
	        
	      #READ_COMPLETE_PACKET:
	        IF (#myPacketReader.xDone) THEN
	          
	          // check if received message is > 0 bytes for variable part
	          IF (#myPacketReader.result > 0) THEN
	            
	              #mqttData.lastInActivity := #mqttData.runTime;
	            
	              #typeOfPacket := BYTE_TO_INT(#mqttData.buffer[0] AND B#16#F0);
	            
	            CASE (#typeOfPacket) OF
	                
	              #MQTT_PUBLISH:
	                // received a PUBLISH, 3.3 PUBLISH – Publish message
	                // refer to MQTT Docs. section 3.3 PUBLISH – Publish message
	                
	                  #tl := WORD_TO_INT(SHL(IN := BYTE_TO_WORD(#mqttData.buffer[#myPacketReader.lengthLength + 1]), N := 8)) + BYTE_TO_INT(#mqttData.buffer[#myPacketReader.lengthLength + 2]);
	                FOR #i := 0 TO #tl - 1 DO
	                    #pubTopicChar[#i + 2] := BYTE_TO_CHAR(#mqttData.buffer[#myPacketReader.lengthLength + 3 + #i]);
	                END_FOR;
	                #pubTopicChar[1] := INT_TO_CHAR(#tl);
	                #paylPos := #myPacketReader.lengthLength + 3 + #tl;
	                #paylSize := #myPacketReader.result - #paylPos;
	                FOR #i := 0 TO #paylSize - 1 DO
	                    #payload[#i] := #mqttData.buffer[#paylPos + #i];
	                END_FOR;
	                #payloadSize := #paylSize;
	                #callback := true;
	                
	                // Check if the Publish messag has QoS = 1, if yes then send PUBACK response
	                IF BYTE_TO_INT(#mqttData.buffer[0] AND B#16#01) = 1 THEN
	                    "mqttPUBACK"(packetIdMSB := #mqttData.buffer[#paylPos - 2],
	                                 packetIdLSB := #mqttData.buffer[#paylPos - 1],
	                                 mqttData:=#mqttData);
	                END_IF;
	                ;
	                
	              #MQTT_PINGRESP:
	                // received a PINGRESP, part of MQTT 3.1.2.10 Keep Alive
	                // (refer MQTT Docs. section 3.1.2.10 Keep Alive, 3.12 PINGREQ – PING request, 3.13 PINGRESP – PING response)
	                
	                  #mqttData.pingOutstanding := false;
	                ;
	                
	              #MQTT_PUBACK:
	                // received a PUBACK package, part of MQTT QoS 1 handshake
	                // (refer MQTT Docs. section 4.3.2 QoS 1: AT least once delivery)
	                
	                #callbackPacketType := "mqttGlobals".MQTTPUBACK;
	                // get the packet ID of the PubAck package and store it in mqttData.recPublishPacketID
	                #structTmpPacketId.byteMSB := #mqttData.buffer[3];
	                #structTmpPacketId.byteLSB := #mqttData.buffer[2];
	                #mqttData.recPublishPacketID := #tmpPacketID;
	                #callback := true;
	                ;
	                
	              #MQTT_PUBREC:
	                // received a PUBREC package, part of MQTT QoS 2 handshake
	                // (refer MQTT Docs. section 4.3.3 QoS 2: Exactly once delivery)
	                
	                // get the packet ID of the PubAck package and store it in mqttData.recPublishPacketID
	                  #structTmpPacketId.byteMSB := #mqttData.buffer[3];
	                  #structTmpPacketId.byteLSB := #mqttData.buffer[2];
	                // send out a PUBREL packet
	                  #mqttData.buffer[0] := INT_TO_BYTE("mqttGlobals".MQTTPUBREL);
	                  #mqttData.buffer[0] := #mqttData.buffer[0] OR SHL(IN := INT_TO_BYTE("mqttGlobals".MQTTQOS1), N := 1); // set qos flag to 2
	                  #mqttData.buffer[1] := 16#02;
	                "mqttSendTCP"(offset := 0,
	                              size := 4,
	                              mqttData:=#mqttData);
	                #mqttData.lastOutActivity := #mqttData.runTime;
	                ;
	                
	              #MQTT_PUBCOMP:
	                // received a PUBCOMP package, part of MQTT QoS 2 handshake
	                // (see MQTT Docs. section 4.3.3 QoS 2: Exactly once delivery)
	                
	                // notify about successfull QoS 2 handshake
	                #callbackPacketType := "mqttGlobals".MQTTPUBCOMP;
	                // get the packet ID of the PubAck package and store it in mqttData.recPublishPacketID
	                #structTmpPacketId.byteMSB := #mqttData.buffer[3];
	                #structTmpPacketId.byteLSB := #mqttData.buffer[2];
	                #mqttData.recPublishPacketID := #tmpPacketID;
	                #callback := true;
	                ;
	                
	            END_CASE; // typeOfPacket
	            
	          END_IF; // myPacketReader.result > 0
	          
	          #intState := #WAIT_FOR_RECEIVED_PACKET;
	          
	        END_IF; // myPacketReader.xDone
	        ;
	        
	    END_CASE; //intState
	    
	END_CASE; // mqttData._state
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "mqttSparkplugPublish"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      mqttParameters { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : "MqttPubParSparkplugUdt";
      usePlainMQTT : Bool;
   END_VAR

   VAR_OUTPUT 
      RetVal : Int;
   END_VAR

   VAR_IN_OUT 
      mqttData : "MqttDataUdt";
      mqttMetric : Array[*] of "MqttPubMetricsSparkplugUdt";
      tcpSendBuf : Array[0..65535] of Byte;
      enable : Bool;
   END_VAR

   VAR 
      sequenceNumber : Byte;
      rTrigConnect {InstructionName := 'R_TRIG'; LibVersion := '1.0'} : R_TRIG;
      connectDone { S7_SetPoint := 'True'} : Bool;
      buffer : Array[0..65535] of Byte;
   END_VAR

   VAR_TEMP 
      length : DInt;
      fixedHeader : Byte;
      holdstring : String[50];
      holdstringLength : Int;
      messageTyp : String;
      thisMessageID : Int;
      payloadLength : Int;
      uuidRandomString : String;
      randowmUDIntError : Bool;
      randowmUDIntStatus : Word;
      randowmUDIntSubStatus : Word;
      offset : Int;
      retValMoveBuffer : Int;
      lengthShift : Word;
   END_VAR

   VAR CONSTANT 
      MESSAGE_TYP_NBIRTH : String := 'NBIRTH';
      MESSAGE_TYP_NDATA : String := 'NDATA';
      SEQUENCE : Byte := 16#18;
      UUID : Byte := 16#22;
   END_VAR


BEGIN
	// connection established to mqtt broker -> send NBIRTH message
	IF  #usePlainMQTT = FALSE THEN
	    #rTrigConnect(CLK := #mqttData._state = "mqttGlobals".MQTT_CONNECTED);
	    IF #rTrigConnect.Q THEN
	        #messageTyp := #MESSAGE_TYP_NBIRTH;
	        #sequenceNumber := 0;
	    ELSIF #connectDone THEN
	        #messageTyp := #MESSAGE_TYP_NDATA;
	    ELSE
	        #messageTyp := '';
	    END_IF;
	    
	    IF (#mqttData._state <> "mqttGlobals".MQTT_CONNECTED) THEN
	        #connectDone := FALSE;
	    END_IF;
	END_IF;
	
	// encode message
	IF (#enable AND ( #connectDone OR #usePlainMQTT = TRUE))
	    OR (#messageTyp = #MESSAGE_TYP_NBIRTH) AND (#connectDone = FALSE)
	THEN
	    // set return value (message ID) to 0
	    #RetVal := 0;
	    
	    // if there's no MQTT connection return an error code
	    IF #mqttData._state = "mqttGlobals".MQTT_DISCONNECTED THEN
	        #RetVal := -1;
	        RETURN;
	    END_IF;
	    
	    // Fixed header, byte 1
	    // +--------+---+-----+---+---+----------+-----+-----+--------+
	    // |bit     | 7 |  6  | 5 | 4 |     3    |  2  |  1  |    0   |
	    // +--------+---+-----+---+---+----------+-----+-----+--------+
	    // |byte 1  | Message Type(3) | DUP Flag | QoS level | RETAIN |
	    // +--------+-----------------+----------+-----------+--------+
	    
	    // set package type in header
	    #fixedHeader := INT_TO_BYTE("mqttGlobals".MQTTPUBLISH);
	    // Set Header Flags for duplicates, qos level and retain
	    #fixedHeader := #fixedHeader OR SHL(IN := BOOL_TO_BYTE(#mqttParameters.mqttPubDuplicate), N := 3) OR SHL(IN := INT_TO_BYTE(#mqttParameters.mqttPubQoS), N := 1) OR BOOL_TO_BYTE(#mqttParameters.mqttPubRetain);
	
	    // Fixed header, byte 2
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bit     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bytes 2..4|   Remaining Length          |
	    // +--------+-------------------------------+
	    
	    // Variable header, topic
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bit     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	    // +--------+---+---+---+---+---+---+---+---+
	    // |byte    |           Topic length MSB    |
	    // +~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
	    // |byte    |           Topic length LSB    |
	    // +~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bit     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bytes    |           Topic              |
	    // +~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
	    
	    // point to buffer area in front of fixed header (5 bytes)
	    // copy topic to buffer
	    IF #usePlainMQTT THEN
	        #holdstring := #mqttParameters.mqttPubTopic;
	    ELSE
	        // concat Sparkplug topic string
	        #holdstring := 'spBv1.0/';
	        #holdstring := CONCAT(IN1 := #holdstring, IN2 := #mqttParameters.mqttSparkplugGroupId);
	        #holdstring := CONCAT(IN1 := #holdstring, IN2 := '/');
	        #holdstring := CONCAT(IN1 := #holdstring, IN2 := #messageTyp);
	        #holdstring := CONCAT(IN1 := #holdstring, IN2 := '/');
	        #holdstring := CONCAT(IN1 := #holdstring, IN2 := #mqttParameters.mqttSparkplugEdgeNodeId);
	        ;
	    END_IF;
	    #holdstringLength := LEN(#holdstring);
	    #buffer[0] := #holdstringLength.%B1;
	    #buffer[1] := #holdstringLength.%B0;
	    #length := 2;
	    Strg_TO_Chars(Strg := #holdstring,
	                  pChars := #length,
	                  Cnt => #payloadLength,
	                  Chars := #buffer);
	    #length := #payloadLength + #length;
	
	    // MessageID  
	    // Variable header, byte 9
	    // +--------+---+---+---+---+---+---+---+---+
	    // |bit     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	    // +--------+---+---+---+---+---+---+---+---+           
	    // |byte    |       Message ID LSB (0)      |
	    // +--------+-------------------------------+ 
	    // |byte    |       Message ID LSB (10)     |
	    // +--------+-------------------------------+
	    
	    // set MessageID if qos level 1 or 2
	    IF (#mqttParameters.mqttPubQoS = "mqttGlobals".MQTTQOS1) OR (#mqttParameters.mqttPubQoS = "mqttGlobals".MQTTQOS2) THEN
	        IF #mqttParameters.mqttPubMessageId > 0 THEN
	            #thisMessageID := #mqttParameters.mqttPubMessageId;
	        ELSE
	            #thisMessageID := "mqttGetNextMessageID"(mqttData := #mqttData);
	        END_IF;
	        
	        // insert message ID
	        #buffer[#length] := DWORD_TO_BYTE(SHR(IN := INT_TO_DWORD(#thisMessageID), N := 8));
	        #length := #length + 1;
	        #buffer[#length] := INT_TO_BYTE(#thisMessageID) AND B#16#FF;
	        #length := #length + 1;
	        
	        #RetVal := #thisMessageID;
	    END_IF;
	    
	    IF #usePlainMQTT THEN
	        REGION MQTT 3.1.1
	            // Payload
	            // Variable header, byte 11...
	            // +--------+---+---+---+---+---+---+---+---+
	            // |bit     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
	            // +--------+---+---+---+---+---+---+---+---+           
	            // |bytes   |           Payload             |
	            // +~~~~~~~~|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+  
	            // copy payload to buffer
	            IF LEN(#mqttParameters.mqttPubPayload) > 0 THEN
	                Strg_TO_Chars(Strg := #mqttParameters.mqttPubPayload,
	                              pChars := #length,
	                              Cnt => #payloadLength,
	                              Chars := #buffer);
	                #length := #payloadLength + #length;
	            END_IF;
	        END_REGION
	    ELSE
	        REGION Sparkplug
	            // encode Sparkplug message
	            "mqttSparkplugEncode"(messageType:=#messageTyp,
	                                  mqttMetric := #mqttMetric,
	                                  buffer := #buffer,
	                                  length := #length);
	                
	            // sequence number
	            #buffer[#length] := #SEQUENCE;
	            #length := #length + 1;
	            #buffer[#length] := #sequenceNumber;
	            #sequenceNumber := (#sequenceNumber + 1) MOD 255;
	            #length := #length + 1;
	            
	            IF #messageTyp = #MESSAGE_TYP_NDATA THEN
	                // UUID
	                #buffer[#length] := #UUID;
	                #length := #length + 1;
	                #uuidRandomString := UDINT_TO_STRING("LGF_Random_UDInt"(error => #randowmUDIntError, status => #randowmUDIntStatus, subfunctionStatus => #randowmUDIntSubStatus));
	                #uuidRandomString := DELETE(IN := #uuidRandomString, L := 1, P := 1);
	                #buffer[#length] := LEN(#uuidRandomString);
	                #length := #length + 1;
	                Strg_TO_Chars(Strg := #uuidRandomString,
	                              pChars := #length,
	                              Cnt => #payloadLength,
	                              Chars := #buffer);
	                #length := #payloadLength + #length;
	            END_IF;
	        END_REGION
	    END_IF;
	    
	    // copy header information (includes remaining length calculation)
	    // and trigger tcpsend
	    #tcpSendBuf[0] := #fixedHeader;
	    // length between 0 .. 127
	    #tcpSendBuf[1] := #length.%B0;
	    #offset := 2;
	    // use second byte if length between 128 .. 16383, 8th bit is a continuation bit
	    IF (#length > 127)
	    THEN
	        #lengthShift := SHR(IN := #length, N := 7);
	        #tcpSendBuf[2] := #lengthShift;
	        #offset := 3;
	    ELSIF (#length > 16383)
	    THEN
	        #lengthShift := SHR(IN := #length, N := 7);
	        #tcpSendBuf[2] := #lengthShift;
	        #lengthShift := SHR(IN := #lengthShift, N := 7);
	        #tcpSendBuf[3] := #lengthShift;
	        #offset := 4;
	    END_IF;
	    #retValMoveBuffer := MOVE_BLK_VARIANT(SRC := #buffer, COUNT := #length, SRC_INDEX := 0, DEST_INDEX := #offset, DEST => #tcpSendBuf);
	    #mqttData.sendSize := #length + #offset;
	    #mqttData.reqSend := true;
	
	    #mqttData.lastOutActivity := #mqttData.runTime;
	
	    // set connectDone if NBIRTH message sent
	    IF (#messageTyp = #MESSAGE_TYP_NBIRTH) THEN
	        #connectDone := TRUE;
	    END_IF;
	    
	    // reset enable
	    #enable := FALSE;
	END_IF;
	
	
END_FUNCTION_BLOCK

